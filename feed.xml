<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://sppfly.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sppfly.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-10T21:05:01+00:00</updated><id>https://sppfly.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">My first experience about cpp</title><link href="https://sppfly.github.io/blog/2025/My-first-experience-about-cpp/" rel="alternate" type="text/html" title="My first experience about cpp"/><published>2025-04-10T00:00:00+00:00</published><updated>2025-04-10T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2025/My%20first%20experience%20about%20cpp</id><content type="html" xml:base="https://sppfly.github.io/blog/2025/My-first-experience-about-cpp/"><![CDATA[<p>After writing some Cpp code, I’m starting to thinking</p> <p>I was a software engineer with 3 years of experience of java, and then 2 years’ studying as a computer science student in Msc.</p> <p>I started to learn C++ recently because I want to do some serious database developing job. But I find it very struggling with even a toy vector class with copy constructor/copy assignment. The problem I found so far :</p> <ol> <li>Bad tools support. I’m writing code with Zed which has native support for cpp with clangd. Zed itself is indeed a beautiful well crafted editor. But clangd really suck.</li> <li>Few direction of best practice</li> <li>Hard to understand the concept</li> </ol>]]></content><author><name></name></author><category term="随想"/><summary type="html"><![CDATA[After writing some Cpp code, I’m starting to thinking]]></summary></entry><entry><title type="html">Streaming</title><link href="https://sppfly.github.io/blog/2023/streaming/" rel="alternate" type="text/html" title="Streaming"/><published>2023-12-29T00:00:00+00:00</published><updated>2023-12-29T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/streaming</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/streaming/"><![CDATA[<h2 id="the-use-of-streaming">The Use of Streaming</h2> <p>Before export the streaming data, people usually process the message or together. The () leaves some hard things: * no sort * then no sort-merge join * how to do recovery if you cannot restart a streaming app which can run for years</p> <h3 id="complex-event-processing">Complex event processing</h3>]]></content><author><name></name></author><summary type="html"><![CDATA[The Use of Streaming]]></summary></entry><entry><title type="html">2023</title><link href="https://sppfly.github.io/blog/2023/2023/" rel="alternate" type="text/html" title="2023"/><published>2023-12-27T00:00:00+00:00</published><updated>2023-12-27T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/2023</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/2023/"><![CDATA[<p>还有一会2023就要结束了，刚做完5840的2A，我也简简单单做个总结。</p> <p>2023年总体上过的就很chill，尤其是来了瑞典以后。当然这其中肯定有一些让人痛苦的时刻，不管是在国内还是在瑞典。</p> <h2 id="1-3月">1-3月</h2> <p>自从22年底拿到VU的offer以后我整个人就开始放松，所以这三个月的核心内容就是过年。这应该是我未来n年里最后一次在家过年了，所以还是想好好享受一下。再则元旦左右正好是国内疫情最严重的时候，所以总体上都没有任何努力工作的欲望。这期间最开心的应该是去天津见了我最好的朋友，虽然在天津又是在酒精作用下毫不清醒的两天。</p> <p>从2月底开始，我也开始腰痛。这奠定了2023年我个人的主基调，就是身体不适。简单来说就是前半年腰痛后半年脖子痛，还阳了3次。要说2023年我最大的收获（教训）就是好好写代码赚钱什么都是次要的，最重要的还是注意身体。身体不舒服的话想法再多也没有什么意义。</p> <h2 id="4-6月">4-6月</h2> <p>3月底拿到了Chalmers的offer，是我一直都想来的学校（甚至为此放弃了带奖的EIT）。随之就开始准备上学的事情，办居留卡、凑钱交学费等等。当然更重要的事情就是玩。这几个月不仅去了计划了很久的南京（顺便还感染了新冠）；也回了趟大连。在大连好好怀念了一下本科时的氛围的同时，我也意识到这玩意就是回来一次就够了。现在回想起来本科四年我过得一点也不快乐，之所以后面一直想回去也只是因为上班头一年更不快乐而已。如果我一直在Citi工作的话想回去的念头恐怕会淡很多。</p> <h2 id="7-8月">7-8月</h2> <p>距离出发没有多少时间了，这两个月的核心内容就是说拜拜。7月在上海和同事与前同事们频繁聚餐，吃到对中餐爱不起来。同时也去了趟宁波，虽然很好吃，但海鲜的价格让我很后悔在大连时没有多吃点。离职前还利用业余时间学了点Kafka Stream的东西，这后来也阴差阳错变成了我做RA的契机。</p> <p>离职以后困扰了我半年的腰痛突然就好了。让我想起来当初去看医生时，医生问我觉得为什么会腰痛，我回答说久坐。医生就说那就不要久坐啊然后把我打发走了。果不其然不上班以后瞬间变好。但是离职回家以后没有显示器，用了半个月笔记本电脑也变成了我后半年脖子痛的导火索。</p> <p>到此为止我在宇宙中心上海的三年工作时光就全部结束了。现在回想起来要比读大学时快乐很多，可能因为没有peer pressure，同时经济独立带来的自信心也很重要。这三年技术上的进步也勉强凑合，服务器开发的东西多少也能说上点。这期间我也尽量每天晚上都学习，虹口和浦东图书馆也去过很多次。但是虽然花的时间不少却学的很杂，自己也总觉得一旦真的要刨根问底的话自己还是什么都不知道，不过这也正是我要来Chalmers的原因。</p> <p>这三年我感觉最大的改变还是心态上的变化。相比于读书时总喜欢和别人比，现在我更关注自己有没有变好。同时对自己做事情的目的也更清楚了，如果我当初刚毕业就来Chalmers读书的话恐怕这两年肯定会浑浑噩噩虚度过去。</p> <h2 id="9-10月">9-10月</h2> <p>8月底终于开始了我这么多年来一直在准备的学业。到达瑞典后感觉一切都很新鲜，我所感觉到的瑞典的自然环境、基础设施和人的友善程度都比国内要好很多。在出发之前我也有纠结放弃看起来还不错的工作来瑞典值不值，等到了以后我感觉如果能让我再做一次选择我还是会来。夏秋之交的瑞典的景色非常漂亮，以前在国内不喜欢拍照的我来了以后也到处拍拍拍。</p> <p>不过一开始在瑞典最难习惯的是食物。哥德堡的亚洲餐馆并不算少，但是高昂的人工成本导致在外面吃饭不管是什么都至少要80人民币。刚来时我做饭的工具也不够齐全，也没做什么像样的事物。所以第一个月只能尽量在食堂吃质量非常随机的模仿亚洲食物。这期间我非常渴望回国吃饭，经常晚上做梦都梦到回国。不过幸好去了几趟中超/宜家之后做饭的条件和国内已经差不多了，对国内食物的渴望降低了不少。</p> <p>瑞典的学制和国内有很大差别。这里每个学年有两个学期，分别是9-12月和1-6月。每个学期再平均分成两个period，每个period学两门课然后考试，也就是说开课7周以后就要准备考试了，相比于国内长达16周的学制这里的感觉就是刚开学就考试了。第一个period的课程是OS和计网。OS课难度很低，考试也都是背PPT。课程的lab相比于OS更像是system programming，难度也不是很大。总体上感觉学了就像没学，甚至大部分人学完都还不知道inode是什么。不过这也可以理解，毕竟2个月对于OS来讲确实是太短了。另一门计网则是一半时间复习网络技术一半时间学自稳定分布式算法。算法部分很多同学说知识太旧了，但是不管旧不旧我学得都非常吃力，让我明白了我终究不适合做理论相关的东西。</p> <p>本来我的计划是上学期间每天都要在学校写代码，第一个period还要做6.1810的lab。但是来瑞典10天左右以后我的脖子和背部就开始痛，严重时甚至没法连续20min以上用电脑。一开始也不知道该怎么解决这个问题，所以每次脖子开始痛时我就开始整天躺在床上休息。所以第一个period的节奏就是学习一周，卧床一周。最后遑论1810的lab，连计网我都是在最后阶段复习了以后才踩线通过。</p> <h2 id="11-12月">11-12月</h2> <p>第一个period艰难地结束了以后很快就开始了第二个period。第二个period的两门课是我一直想上的分布式系统和图形学。</p> <p>但是随之一并开始的又是脖子痛。在此期间我尝试了各种各样的方法，包括睡地板，换枕头和用升降桌等等。但这些都没什么效果，长期脖子痛也严重影响了我的作息和心情。我的作息逐渐变成了两三点睡中午才醒（完美错过了大部分瑞典天亮的时候），同时我</p> <p>看了医生之后</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[还有一会2023就要结束了，刚做完5840的2A，我也简简单单做个总结。]]></summary></entry><entry><title type="html">Self-stabilization</title><link href="https://sppfly.github.io/blog/2023/diary/" rel="alternate" type="text/html" title="Self-stabilization"/><published>2023-09-26T00:00:00+00:00</published><updated>2023-09-26T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/diary</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/diary/"><![CDATA[]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Self-stabilization</title><link href="https://sppfly.github.io/blog/2023/self_stable/" rel="alternate" type="text/html" title="Self-stabilization"/><published>2023-09-21T00:00:00+00:00</published><updated>2023-09-21T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/self_stable</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/self_stable/"><![CDATA[<h2 id="definitions-techniques-and-paradigms">Definitions, Techniques and Paradigms</h2> <h3 id="21-definitions-of-the-computation-model">2.1 Definitions of the Computation Model</h3> <p><strong>Processor</strong>:</p> <h3 id="22-self-stabilization-requirements">2.2 Self-Stabilization Requirements</h3> <h3 id="23-complexity-measures">2.3 Complexity Measures</h3> <h3 id="34-ramdomized-self-stabilization">3.4 Ramdomized Self-Stabilization</h3> <h3 id="25-spanning-tree-construction">2.5 Spanning-Tree Construction</h3> <h3 id="26-mutual-exclusion">2.6 Mutual Exclusion</h3> <h3 id="27-fair-composition">2.7 Fair Composition</h3> <h4 id="example-mutual-exclusion">Example: Mutual Exclusion</h4> <h3 id="28-recomputation-of-floating-output">2.8 Recomputation of Floating Output</h3> <h4 id="example-synchronous-consensus">Example: Synchronous Consensus</h4> <p>###</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Definitions, Techniques and Paradigms]]></summary></entry><entry><title type="html">瑞典这一个月</title><link href="https://sppfly.github.io/blog/2023/%E7%91%9E%E5%85%B8%E4%B8%80%E6%9C%88/" rel="alternate" type="text/html" title="瑞典这一个月"/><published>2023-09-12T00:00:00+00:00</published><updated>2023-09-12T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/%E7%91%9E%E5%85%B8%E4%B8%80%E6%9C%88</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/%E7%91%9E%E5%85%B8%E4%B8%80%E6%9C%88/"><![CDATA[<p>今天是2023年9月12号，距离8月21号抵达瑞典已经二十多天了。经过一段时间的适应，我在查姆的生活和学习也渐渐稳定下来。现在在此记录一下，权当对第一次出国生活的回顾。希望等有一天我离开瑞典时，。</p> <h2 id="抵达">抵达</h2> <p>我于2023年8月21号乘坐航班经赫尔辛基</p> <h2 id="第一印象">第一印象</h2> <p><strong>首先说明：本段设计到的所有内容均无种族主义倾向，所有内容仅为事实陈述。所有事实仅为本人体验，不具有推广意义。</strong></p> <ol> <li>人口密度</li> </ol> <p>2023年哥德堡的人口大约是67万[^1]，仅仅相当于上海黄浦区的人口。所以在哥德堡的日常体验就是路上人很少。仅仅在哥德堡400周年纪念游行的现场我才体验到了在国内每天都能体验的摩肩接踵的感觉。一开始上午十点去学校食堂吃中饭时，马路上稀稀拉拉的就只有一两个人，总让我有种今天是过年/国庆大家都不在学校的感觉。</p> <p>其实欧洲人对中国人口数量也有所耳闻。在学校CS迎新活动时，我说我来自中国一个小城镇，有同学立即说“一个有1000万人口的小城镇是吧”。直到我说我家县城人口和哥德堡差不多，他们才觉得那真是小城市。瑞典整个国家的人口只有1000万，首都斯德哥尔摩是人口最多的城市，但也只有120万人口，仅仅比渭南市临渭区人口多一点。所以上海这种2500万人住在同一个城市对他们来说是很难想象的事情。</p> <ol> <li>肤色和身高</li> </ol> <p>从赫尔辛基下飞机准备转机时，我的第一印象就是这里的人好高好白。在国内时偶尔遇到190cm的人会觉得他鹤立鸡群，但是在飞机场只感觉到处都是这么高的</p> <ol> <li></li> </ol> <p>在北欧这些天我遇到的所有服务人员（这里包含服务业从业人员、政府工作人员、学校的Info desk和街边发传单的等等）都是面带微笑的。这点和国内</p> <ol> <li>自然环境</li> </ol> <p>和国内（至少和我生活过的地方）相比我最喜欢的就是瑞典的自然环境。气候宜人，天气稳定，环境优美。夏天的瑞典我觉得可以称之为人间天堂。我在国内时</p> <ol> <li> <p>交通 哥德堡没有地铁，室内交通主要靠有轨电车和公共汽车。去远一点的地方可以坐火车，去西边的哥德堡群岛可以坐船。</p> </li> <li> <p>清净</p> </li> </ol> <p>这一点是我和一些同学的共同认识，大家都不约而同的有一样的感觉。清净主要体现在：</p> <ol> <li>人少，清净是正常的。</li> <li>生活节奏慢。在国内时生活节奏很快，总觉得时间不够用。但是这边干什么</li> <li>没有遭心的新闻</li> <li>没有广告和消费主义。在国内大城市生活时，我和一些同学有类似的经历：偶尔打开淘宝，推荐算法给我推荐了看起来非常好又很划算（但实际上很贵）的东西，下狠心买到以后放在家里吃灰。四位数的积蓄就这么被浪费了。或者偶尔和朋友去市中心逛，市中心豪华又fancy，大商场干净又体面，但是。眼花缭乱的广告的夸张的收入差距每天变着法地冲击你的眼球。 但是在瑞典以上的经历都没有：网购及其不发达，配送成本很贵；市中心也没有国内那么繁华，价格也没有国内那么贵；2018年新建的公寓一平米也只要30000克朗，然而哥德堡2022年的税前平均薪水是45000克朗。查姆身处哥德堡的富人区，别墅下面停的车也就是普通的奔驰宝马。</li> </ol> <p>比国内不好的或是不方便的地方</p> <ol> <li> <p>物价</p> </li> <li> <p>食物</p> </li> </ol> <p>作为一个</p> <ol> <li>社交 z</li> </ol> <p>[^1] https://worldpopulationreview.com/world-cities/gothenburg-population#:~:text=Gothenburg%20is%20a%20city%20in%20Sweden%20that%20is,has%20a%20population%20that%20exceeds%201%20million%20residents.</p>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[今天是2023年9月12号，距离8月21号抵达瑞典已经二十多天了。经过一段时间的适应，我在查姆的生活和学习也渐渐稳定下来。现在在此记录一下，权当对第一次出国生活的回顾。希望等有一天我离开瑞典时，。]]></summary></entry><entry><title type="html">一月学习总结</title><link href="https://sppfly.github.io/blog/2023/studying_review/" rel="alternate" type="text/html" title="一月学习总结"/><published>2023-09-10T00:00:00+00:00</published><updated>2023-09-10T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/studying_review</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/studying_review/"><![CDATA[<p>上篇文章主要讲我对瑞典的生活印象，这篇文章则讲最近一个月的学习状态，毕竟我的积蓄不是大风吹来的。</p> <p>当初来瑞典的主要目的是想找一个清净的地方能够沉浸在我想学的东西当中，现在回想一下第一个月还是没有沉浸其中。虽然到达的第三天我就开始尝试学习了，但是目前仍然没有找到合适的方案能实现从早晨八点学到晚上十点。</p> <p>我来哥德堡之前开始的学习的课程有:</p> <ol> <li>UCB的CS186，lab做完了B+树</li> <li>UCB的CS61C，lab做完了贪吃蛇</li> <li>MIT的6.1810,lab做完了util的一半</li> <li>Stanford的CS144,刚开始，lab一个都没有做</li> </ol> <p>我原本定的计划是第一个Period做完6.1810和CS144，因为正好的学校学的两门课重合。但是后来这一个月过去发现基本不可能实现，原因有：</p> <ol> <li>自身原因：还没有找到一个固定的周期能让自己按计划做事情</li> <li>低估了学校本身课程的工作量: 因为我自己的要求是要一个人写完查姆学校group work的所有Lab，所以花的时间还是挺多的。比如OS lab1写一个shell其实也是移植了CalTech的OS作业，难度并不小。其次Network的lab虽然有框架，但是要想学会（至少知道Scoket）怎么用还是要自己重新写框架。再者Network学的self-stabilization我上课什么都听不懂全靠下课自学，所以要拿两个5还是有难度的。</li> <li>MIT和Stanford的课本身也挺难的。尤其是CS144是用C++写，我以前从来没写过C++。写到Check1才发现自己连Move和Copy都不知道，又要补C++的知识，所以一个Period做完简直是天方夜谈。</li> </ol> <p>所以应该好好规划一下自己的学习计划，以前什么都想做的计划到最后可能什么都没做完。所以新的计划应该是按照period:</p> <ol> <li>6.1810</li> <li>6.5840</li> <li>cs61c</li> <li>cs186</li> <li>cs144</li> </ol>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[上篇文章主要讲我对瑞典的生活印象，这篇文章则讲最近一个月的学习状态，毕竟我的积蓄不是大风吹来的。]]></summary></entry><entry><title type="html">Well ground Java Developer</title><link href="https://sppfly.github.io/blog/2023/Well-ground-Java-Developer/" rel="alternate" type="text/html" title="Well ground Java Developer"/><published>2023-02-15T00:00:00+00:00</published><updated>2023-02-15T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2023/Well%20ground%20Java%20Developer</id><content type="html" xml:base="https://sppfly.github.io/blog/2023/Well-ground-Java-Developer/"><![CDATA[<h2 id="chapter-1-introduction-to-modern-java">Chapter 1 Introduction to modern Java</h2> <h3 id="java-语言与平台">Java 语言与平台</h3> <p>提起Java这个词，很多人第一印象都是Java语言。Java语言在从出生开始到现在这30年里一直叱咤风云。但是在现代意义上讲，Java代表的已经不局限于Java语言了，而是Language + Platform。大体上讲，Java这个商标由Oracle拥有并管理。Oracle负责Java SE的开发，根据Java SE官网，Java SE 19的标准分为两部分：</p> <ul> <li> <p>The Java Language Specification, Java SE 19 Edition</p> <p>Preview feature: Pattern Matching for switch； Record Patterns</p> </li> <li> <p>The Java Virtual Machine Specification, Java SE 19 Edition</p> </li> </ul> <p>其中 The Java Language指的就是那门原教旨面向对象的编程语言，而Java Virtual Machine就是Java程序员面试需要背诵但是从来都用不上的JVM。实际上JVM的官方实现已经没有任何和Java语言相关的字眼，对于JVM来说Java语言和其他任何一个可以编译为Bytecode的语言（Kotlin或Scala）一样。</p> <h3 id="java-发布模型">Java 发布模型</h3> <p>从2021年开始，Java每两年一个LTS，半年一个STS（看起来像是被别的语言刺激了）。 值得注意的是，JDK中有一些独立的OpenJDK project可能贯穿多个JDK的生命周期，每个project做的事情都不一样。比如Project Loom致力于在Java中实现协程，而Project Amber致力于让程序员少写代码。</p> <h2 id="chapter-13-testing-fundamentals">Chapter 13 Testing Fundamentals</h2> <h3 id="131-如何测试">13.1 如何测试？</h3> <p>软件的测试大致可以分为：</p> <ul> <li>单元测试</li> <li>集成测试</li> <li>端到端测试</li> </ul> <p>他们之间的关系可以用一个金字塔来表示：</p> <p><img src="/assets/img/pyramid.png" alt="pasad" title="the pyramin"/></p> <p><strong>单元测试：</strong> 单元测试构成了整个金字塔的最底部。每个单元测试之间的隔离性最强，运行速度最快，所覆盖的内容也最单一。理想状态下，单个单元测试应该只测试单个功能。这里的单个功能指的是：自己的与外部依赖无关的逻辑。当所测试的逻辑有外部依赖时，如使用了数据库调用或者RPC，外部依赖返回的结果应该使用Mock的理想结果，这个叫做test double。</p> <p><strong>集成测试：</strong> 集成测试和单元测试之间的关系有时是模糊的。但仍然可以确定的是：集成测试只测试整个系统的一部分，另外仍有一部分依赖是被Mock的。比如：一个测试只测试某个后端服务的一个借口，这个后端服务中使用真实的数据库和RPC连接，而假定前端部分是完美的。</p> <p><strong>端到端测试：</strong> 端到端测试是最直观的测试，就是假定自己是用户，测试整个系统的输出是否与自己所期望的相匹配。</p> <h2 id="132-测试驱动开发">13.2 测试驱动开发</h2>]]></content><author><name></name></author><category term="Notes"/><summary type="html"><![CDATA[Chapter 1 Introduction to modern Java]]></summary></entry><entry><title type="html">Java SE, Java EE, and Spring Framework</title><link href="https://sppfly.github.io/blog/2022/Java-SE,-Java-EE,-and-Spring-Framework/" rel="alternate" type="text/html" title="Java SE, Java EE, and Spring Framework"/><published>2022-11-05T00:00:00+00:00</published><updated>2022-11-05T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2022/Java%20SE,%20Java%20EE,%20and%20Spring%20Framework</id><content type="html" xml:base="https://sppfly.github.io/blog/2022/Java-SE,-Java-EE,-and-Spring-Framework/"><![CDATA[<p>I didn’t know what exactly Java EE is for a long time. After reading a whole bunch of documents from Spring/Eclipse/Wikipedia, finally I understand the relationship between those technologies.</p> <h3 id="java-se">Java SE</h3> <p>Java Standard Edition is what usually we call ‘Java’. OpenJDK is the official reference implementation. It consists of both Java Language Specification, Java Library, and Java Virtual Machine Specification. So Java SE and JDK can be used interchangeably.</p> <h3 id="java-ee">Java EE</h3> <p>Java Enterprise Edition is a collection of specifications. It consists of APIs like web service(Servlet), persistence(JPA), Bean validation, Json data-bind, annotation, mail, and transaction management. To use these specifications, you will have to import both the specification itself and its implementation. For example, if you want to write a web server, you will have to write it with Servlet and let your program run in a Servlet container like Apache Tomcat or Jetty. If you want operation with a database, you will probably use JPA and one of its implementation Hibernate ORM. In a nutshell, Java EE is a series of specifications that can boost the development of enterprise Java programs. There may be multiple implementations for every specification, such as Jetty, Glassfish, and Apache Tomcat for Servlet.</p> <h3 id="spring-framework">Spring Framework</h3> <p>You may consider it strange to place Spring here because it does different things with Java SE and Java EE. However, according to Spring’s documentation, it does have some relationship with them. Spring was started as a response to the complexity of J2EE, it selects some specific Java EE specifications like Servlet instead of embracing the whole of it, which makes Spring more light-weighted and easier to use.</p>]]></content><author><name></name></author><category term="随想"/><summary type="html"><![CDATA[I didn’t know what exactly Java EE is for a long time. After reading a whole bunch of documents from Spring/Eclipse/Wikipedia, finally I understand the relationship between those technologies.]]></summary></entry><entry><title type="html">信息建索的评价</title><link href="https://sppfly.github.io/blog/2021/%E4%BF%A1%E6%81%AF%E5%BB%BA%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/" rel="alternate" type="text/html" title="信息建索的评价"/><published>2021-12-21T00:00:00+00:00</published><updated>2021-12-21T00:00:00+00:00</updated><id>https://sppfly.github.io/blog/2021/%E4%BF%A1%E6%81%AF%E5%BB%BA%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7</id><content type="html" xml:base="https://sppfly.github.io/blog/2021/%E4%BF%A1%E6%81%AF%E5%BB%BA%E7%B4%A2%E7%9A%84%E8%AF%84%E4%BB%B7/"><![CDATA[<p>Evaluation 对于一个新的信息建索算法，我们该如何去判断这个算法的好坏呢？ 宏观上来看，一个好的算法上线以后，用户的反馈会发生变：用户的点击更多，对于电商网站来说，用户花的钱更多，并且用户可能会有重复的点击行为。但是这些反馈很难量化地评估，因为在此期间可能页面的UI发生了变动，导致用户不喜欢这个网站。我们需要一个评估搜索算法好坏的标准。 实际上，搜索算法的评估需要三个元素：</p> <ol> <li>和大多数机器学习问题一样，搜索算法的评估需要一个数据集，</li> <li>测试的query</li> <li> <p>query和document之间的关联度。 前两者只要从日常的搜索日志中提取即可，但是如何评估一个query和搜索到的document的关联度的呢？</p> </li> <li>无排序搜索 无排序搜索将文档视为set，并不关心搜索结果的顺序，只关心搜索结果与query的相关性。对于一个搜索q，准确率 \(precision=\frac{搜索到的相关文档数量}{搜索到的文档数量}\) 召回率 \(recall=\frac{搜索到的相关文档数量}{相关文档数量}\) 更加准确地来说：</li> </ol> <p>relevant nonrelevant retrieved tp(true positive) fp(false positive) Not retrieved tn(true negetive) fn(fase negetive)</p> <p>\(p =\frac{tp}{tp+fp}\) 对于以上的四种情况来说，很明显tp和fn是准确的搜索结果：相关的都被搜到了，而不相关的都没有被搜到，所以可以很直观地得出一个无排序搜索的评价标准：accuracy \(r=\frac{tp+fn}{tp+fp+fn+tn}\) 对于很多机器学习的二分类问题来说这是一个很好的评价标准:正确的结果的比率，只不过此时的recall不再具有召回的意味。 召回率与查准率是一对相互冲突的指标，通常用F measure作为对两者的trade-off:F measure是两者的调和平均： \(f = \frac{1}{a\frac{1}{p}+(1-a)\frac{1}{r}}\) 然而对于搜索的问题来说，仍然存在一些问题：如果</p> <ol> <li>有排序搜索 考虑以下实例：对于一个搜索，结果集为 \(D_0, D_1, D_2, D_3, D_4, D_5\) 各结果对应的相关度为 \(3, 2, 3, 0, 1, 2\) 数字越大代表结果与搜索越相关。 CG, DCG和NDCG CG(cumulative gain)中文翻译为累计增益。此处用Gain这个词可能是因为，对于query的每一个结果，其相关度用数字来表示，如5表示非常理想，1表示根本毫无关联。这个相关度即可看作对于一个结果的增益，增益大的结果应当在结果集的上方出现。 顾名思义，CG为所有增益的累计， \(CG_p=\sum_{n=1} ^{p} rel_i\) 对于上面的例子： \(CG_6=3+2+3+0+1+2=11\) 结果集内元素的顺序的调换不会影响CG的大小，所以CG能衡量的内容比较有限。 DCG DCG(Discounted CG)，discount原意为商品打折，此处指gain加权， DCG: \(DCG=\sum_{n=1}^{p} \frac{rel_i}{log_2(i+1)}\) DCG给每一个结果的相关度乘以一个系数，这个系数大小随着位置的增大而减小。因此：更相关的结果排名靠后时，DCG会变小；越相关的结果排名越靠前，则DCG越大。 对于上面的例子， \(DCG_6=6.681\) DCG也有一些变种，但是也都换汤不换药，比如： \(DCG=\sum_{n=1}^{p} \frac{2^{rel_i} -1}{log_2(i+1)}\) DCG可以衡量一个query的结果集的排序的好坏，但是各个query的结果数量不一样，对于有多个query的数据集，DCG无法衡量两者排序的好坏，我们需要一个归一化的DCG NGCG(Normalized DCG) nDCG指归一化的DCG，对于一个query， \(nDCG=\frac{DCG_p}{max(DCG_p)}\) DCG的最大值即排序最理想的情况下的DCG，此时结果的排序与相关度的排序相同。很明显nDCG的取值范围为(0, 1]，可以用于跨query的比较。 使用nDCG的缺陷在于：很难获得完整</li> </ol>]]></content><author><name></name></author><category term="Information retrieval"/><summary type="html"><![CDATA[Evaluation 对于一个新的信息建索算法，我们该如何去判断这个算法的好坏呢？ 宏观上来看，一个好的算法上线以后，用户的反馈会发生变：用户的点击更多，对于电商网站来说，用户花的钱更多，并且用户可能会有重复的点击行为。但是这些反馈很难量化地评估，因为在此期间可能页面的UI发生了变动，导致用户不喜欢这个网站。我们需要一个评估搜索算法好坏的标准。 实际上，搜索算法的评估需要三个元素：]]></summary></entry></feed>